### 2092.Find-All-People-With-Secret

很直观的想法是将所有的meeting按照时间先后顺序排列。同时为一个集合来记录哪些人已经知道秘密。对于任何一个新meeting，如果有一方已经在这个集合里，那么另一方也就可以加入集合。

本题的难点在于如果有若干个会议的时间相同怎么办？对于一批同时间的会议，可能第一个会议的A和B都不知道，但是在第二个会议里B从C知道了这个秘密，那么根据规则A也会在此时刻知道这个秘密。加入第三个会议是A与D，那么D也应该知道秘密。

可见，对于同一时刻的会议，我们很难有个比较合适的处理顺序。当然，你可以用类似拓扑排序的思想：先处理有知情者的会议，然后扩大知情者的集合；再查看剩下的会议里还有哪些知情者，再处理掉这些会议，扩大知情者集合... 不过这样的代码，想要满足线性的时间，不见得好写。

考虑到在同一个时间的会议，知情人有着明显的传递性，用并查集是再适合不过的算法了。我们将凡是有会议的双方都union起来。最后查看这些新处理的人，是否有被union到了0（即所有知情人的祖先）。如果有，就加入集合；如果没有，记得撤销这个人的任何union操作，即```Father[i] = i```，因为在这个时刻两个人的union状态，不能带入下一个时刻。举个例子，四点钟A与B会面了。五点钟A知情了，但不意味着五点钟B就会知情。
