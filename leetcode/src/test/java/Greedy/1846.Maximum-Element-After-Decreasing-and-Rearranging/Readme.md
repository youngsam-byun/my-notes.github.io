### 1846.Maximum-Element-After-Decreasing-and-Rearranging

观察到arr[0]必须是1，这是一个非常小的数。因为约束关系，arr[1]最大不能超过2，意味着极有可能我们必须将某个数削减之后才能安放到arr[1]。为了尽量保留较大的数字，我们一定会arrange，选择此时最小的元素放在index=1这个位置，这样就算这个数被decrease也不心疼。所以以此类推，提示我们首先需要将arr按照从小到大排序。

接下来的操作和```LC 135```和```LC 1840```很相似的做法。我们先从左往右遍历，为了尽量减少decrease，我们希望arr[i]尽量取大，但是不能超过arr[i-1]+1，由此切割一下各个元素的上限. 然后再从右往左遍历，同理，为了尽量减少decrease，我们希望arr[i]尽量取大，但是不能超过arr[i+1]+1，由此再切割一下各个元素的上限. 

这两步操作之后，每个arr[i]都贴在上限，这是必要条件，不能再大了，否则就肯定不满足要求了。那么此时的arr是否已经满足要求了呢？是的。我们已经保证了每个arr都不会比邻居多1，所以这是充分的。最终答案就是在此时的arr里面挑个最大的。
