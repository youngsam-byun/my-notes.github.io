### 2311.Longest-Binary-Subsequence-Less-Than-or-Equal-to-K

#### 解法1：
我们将k同样也转化为二进制的字符串，标记为t。我们令s的长度是m，t的长度为n。注意，因为k是个整形，n的长度不会超过32.

接下来考虑题目中说的“最长”是什么意思。通常情况下，长度小于n的二进制数一定小于k，长度大于n的二进制数一定会大于k，“最长”不就是n吗？本题的关键点在于leading zeros。所以，我们希望尽可能地在期望的subsequence前面堆积0，这就意味着我们希望将subsequence放在s里尽量靠后的位置。

所以我们本题的做法就是：在s里从后往前依次寻找一个起点位置i，判断是否存在一个从i开始的subsequence，使其小于等于t，有的话就再加上s[0:i-1]里的所有0的个数，就是期望的总长度。最后，我们在所有的i的选择里面挑一个答案最长的。

那么指定了起点i，如何判断是否存在一个subsequence小于等于t呢？用递归的方法贪心地扫描即可。如果t[j]是0，那么s[i]必须是0，于是移动i直至找到0，与之match，双指针再自增1。如果t[j]是1，那么如果s[i]是0，直接OK；如果s[j]是1，那么与之match，双指针都自增1.

这种方法的时间复杂度是o(N^2)

#### 解法2：
在解法1的基础上，事实上我们不需要遍历所有起点位置，只需要考察一个位置i=m-n，也就是只需要考察最后一个长度为n的substring即可。这是为什么呢？

先考虑basic plan：只看最后n-1长度的substring（必然小于t），再加上[0:m-n]之间的所有的0. 这显然是一个合法的解。

再考虑如果以i=m-n为起点、长度为n的substring，如果大于t的话（显然s的第i位必然是1），那么说明什么？说明缺0。我们必须将i往前移，目的是为了能够引入0，这样才可能将之后的subsequence的大小降下来。但是一旦真的能引入一个0进入subsequence，那么代价就是损失了一个leading zero。那么收益呢？收益就是将subsequence的匹配度从n-1提升到n而已，并没有优势。

所以本题非常简单，在考察完basic plan之后，只需要查看取最后长度n的substring是否为另一个plan即可。时间复杂度是o(N).
