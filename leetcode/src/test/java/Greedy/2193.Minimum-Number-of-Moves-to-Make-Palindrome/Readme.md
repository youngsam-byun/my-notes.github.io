### 2193.Minimum-Number-of-Moves-to-Make-Palindrome

#### 解法1：贪心加暴力模拟
这道题存在着一个非常直观的贪心策略，我们从左往右遍历每个字符s[i]，找到与它能够组成回文对称的那个s[j]，那么将其从j移动到与s[i]回文对称的位置（在总长度是偶数的条件下就是n-1-i）即可。如果暴力地用swap来模拟这个过程，那么就是o(N^2)的复杂度：遍历i是o(N)，对于每个i，用o(N)找到j，并且将j移动到n-1-i。

那么这个贪心策略如何证明呢？也就是说，如果当前字符串最左边是x，那么为什么我们贪心地就把一对x调整到最外层，而不是把其他的一对y调整到最外层呢？我们不失一般性地描述出x和y可能的位置位置关系：
1. ```x ... y... y ... x .....``` 很明显，我们必然先搬动这对x到外侧，再搬动这对y到x的内侧
2. ```x ..(a).. y..(b).. x ..(c).. y ..(d)..``` 我们用abcde表示每段区间的长度。    
    (1) 策略1是将x搬动到外侧，那么需要 0 + (c+d+1)，再搬动y到x的内侧，需要(a) + (d)    
    (2) 策略2是将y搬动到外侧，那么需要 (a+1) + (d)，再搬动x到y的内侧，需要 0 + (c+d)    
    我们惊奇地发现上面两种策略的总和都是 2d+a+d+1
3. ```x ..(a).. x..(b).. y ..(c).. y ..(d)..``` 
    (1) 策略1是将x搬动到外侧，那么需要 (0) + (b+c+d+2)，再搬动y到x的内侧，需要 (a+b) + (d)
    (2) 策略2是将y搬动到外侧，那么需要 (a+b+2) + (d)，再搬动x到y的内侧，需要(0) + (b+c+d)    
    我们惊奇地发现上面两种策略的总和都是 2d+a+b+c+2
    
所以我们得出结论，无论什么情况下，我们只需要把最左边的x固定，将另一个对称的x放到左右边，就是当前的最佳策略。处理完之后就可以剥除最外面一对，递归处理剩下的字符串即可。

补充：为什么我们要关注次外层？这里的逻辑是，我们如果想证明“把x放在最外层”比“把y放在最外层”的操作更优，我们除了要计算x和y的移动次数之外，还必须保证两种操作结束之后剩下的字符串状态是一样的，这样才是公平的比较。单纯地把x移到最外层、或单纯地把y移到最外层，遗留的字符串状态大概率还是不一样，我们也就无法得知后续操作谁更有优势。在视频的分析中，无论我们选哪个y，x都更比y更适合作为最外层，那么显然x就是做为最外层的最优解。

OK，以上我们只是考虑了总长度是偶数的情况。如果回文串长度是奇数，那么在上述“递归处理”的过程中，我们会遇到这样一种情况：此时字符串的最左边是一个仅出现一次的字符（记做w）。那么我们要对w做什么处理呢？答案是我们应该直接忽略掉它，先处理下一个。也就是说，只有在处理完剩下的所有配对之后，再去考察w需要位移几次（就是n/2与w所在index之差）。比如说waabb，正解是忽略w，先调整得到wabba，再将w插入abba的中央，总的交换次数是4. 如果我们试图先将w放入中央得到aawbb，那么再使得aabb对称的话，总的交换次数就需要2+3。

#### 解法2：贪心加统计逆序对
上面的贪心解法配合的是暴力移动。事实上我们有“虚拟移动”的方法来提高效率。

根据前面的分析，最优的做法其实分三步：1. 将所有配对字符的左半边，按照其出场顺序移动到字符串的左侧。2. 如果总长度是奇数，那么将落单的字符移动到n/2的位置。3. 此时剩余的字符（即所有配对字符的右半边）仍然是按照出场顺序排列的，但是都已经挪到了字符串的右侧，此时我们只需要将这个乱序的substring进行操作，使得顺序变得和左侧（更确切地说是与左侧的倒序）一致即可。

举个例子，假设在第1步里第一个遇到的是字符a，与之配对的另一个a的位置是7；第二个遇到的是字符b，与之配对的另一个b的位置是5；第三个遇到的是字符c，与之配对的另一个c的位置是9. 那么说明在原始串579这些位置的字符，我们希望通过adjacent swap的操作最终变为957的顺序。因为最右侧的7对应着与a配对，中间的5对应着与b配对，左边的9对应着与c配对。

那么需要多少次adjacent swap使得579变成957呢？这个问题等价于将一个乱序957变成顺序579. 这是一个经典题，答案是统计所有逆序对的个数。在这里(9,5)和(9,7)是逆序对（即前者大于后者），所以我们只需要两次交换就可以将957->579. 而求逆序对，就是LC.493的原题。

别忘了第1步和第2步我们也需要统计交换的次数。我们需要用count来统计在第一步的过程中已经处理了多少个left-pair的字符，那么我们在遇到一个新的left-pair字符时（记当前位置是i），那么意味着我们要将它从位置i移动到位置count，所以需要i-count次操作。

如果我们在位置i遇到了前述的落单字符w，那么它需要移动多少次呢？注意，我们本质上是需要把所有left-pair都处理完（即第一步）之后再计算w的移动次数。第一步处理完之后，意味着会有n/2-count个left-pair字符会移动到w前面，这意味着它的位置其实是被挤到后面去了，实际是i+(n/2-count)。然后我们需要将w放置在w/2的地方，所以移动步数是```i+(n/2-count) - n/2 = i-count```.

