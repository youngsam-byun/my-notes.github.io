### 984.String-Without-AAA-or-BBB

#### 解法1： 贪心
假设A的频次比B多。因为题目保证总有答案，所以一定有```A<=B*2+2```.

我们可以先构建```ab ab ab...ab ab```，然后将多余的a，往每个ab段之间分别插入。还有更多的的a的话（最多两个）就再加在最后。

#### 解法2： 优先队列
对于这类题目，按照频次从大到小在优先队列里排列是个套路解法。

假设A的字符比B多。总体的算法思想是：

1. 每回合要取两种字符。否则这个回合取字符A的话，下一个回合A可能还是频次最多的字符，依然会取到A，就可能使得连续的A的数目超标。所以每回合加入一个B，就能够阻断两个回合的A相邻接。

2. 每回合中每种字符所取的数目，是为了使得剩下每种字符的数目尽量相等。（假想手头的A和B数目相等，那么之后的构造就非常容易，就不停ABAB...即可。）那么如何确定每个回合A取多少个呢？很简单，如果A的频次比B的频次多一个以上，就取两个A加一个B。这样做既可以避免连续的A超标，也最大限度地拉近了剩余两个字符的频次。

不断重复上述每个回合的操作。直到最后队列里只剩一种字符，并且那个字符的个数不超过2，那么直接加在ret最后即可。
