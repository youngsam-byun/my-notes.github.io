### 2213.Longest-Substring-of-One-Repeating-Character

字符串里连续的相同字符可以视为一个区间，那么整个字符串就包含了若干个“紧密”贴合的区间。我们可以用一个有序map来放置这些区间，将key设置为区间首的位置，val设置为区间尾的位置，并且map自动按照key来排列。

对于任何一个字符的改变，可能会产生一个或者多个新区间，也有可能会造成一些区间的合并，似乎头绪非常繁杂。在这里，一个比较好的思路就是分三步走：当改变位于idx的字符时，先无脑地新增一个区间[idx,idx]，然后再考察往右合并邻接区间（如果可能的话），再考察往右左并邻接区间（如果可能的话）。

当我们考虑新增区间时，需要先找出原先包含idx的区间[a,b]，其中a<=idx<=b。我们用```prev(Map.upper_bound(idx))```得到的最后一个小于等于idx的位置。接下来分为四种可能：
1. 如果a==b==idx，那么不用变化
2. 如果a==idx<b，那么我们要删除区间[a,b]，添加区间[a,a]和[a+1,b]
3. 如果a<idx==b，那么我们要删除区间[a,b]，添加区间[a,b-1]和[b,b].
4. 否则说明idx落入(a,b)内部，那么我们要删除区间[a,b]，添加区间[a,idx-1],[idx,idx]和[idx+1,b].

然后我们考察[idx,idx]这个区间能否和右边的区间（记做[a,b]）合并。如果可以的话，我们就删除区间[idx,idx]和[a,b]，添加区间[idx,b].

然后我们考察[idx,c]这个区间（因为考虑到上面的合并操作）能否和左边的区间（记做[a,b]）合并。如果可以的话，我们就删除区间[idx,c]和[a,b]，添加区间[a,b].
