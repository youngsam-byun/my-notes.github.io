### 1819.Number-of-Different-Subsequences-GCDs

nums有10^5个元素，那么subsequence的组合总共有2^(100000)种，列举每一种序列并求他们的GCD是不现实的。我们转换一个思路，nums的元素的上限是2e5，说明任何序列的GCD肯定也不会超过这个数字。那么是否我们是否可以列举所有小于2e5的数字，然后高效判断它是否属于某个序列的GCD呢？

举个例子，对于数字4，它是否可能是某个序列的GCD呢？首先，我们需要这个序列都是4的倍数。例如，如果数组里出现了[4,8,12,16...]，那么4就是他们的GCD。那么是否只要有4的倍数出现，4就算作一个符合条件GCD呢？并不是，比如数字中只有[8,16,32...]，我们发现他们的最大公约数其实是8而不是4. 因此我们需要数组中有某些4的倍数组成的序列，他们的最大公约数只能是4，而不是4的其他倍数。考虑到序列元素越多，公约数越小。所以，以上就等价于数组中所有的4的倍数组成的序列，他们的最大公约数必须恰好是4，而不是4的其他倍数.

OK，那么我们会固定考察4，然后遍历数组找出所有4的倍数再求GCD；再固定考察5，重复一遍这样的操作吗？这样的效率显然不高。我们可以直接处理每个数组元素a找出它的所有因数fi. 对于fi而言它的一个倍数就是a。我们可以设立一个hash表，记录每个因数fi在数组中出现的它的倍数所累积的GCD。比如说a分解出fi，fi第一次出现，那么记录```g(fi)=a```；另外b分解出fi，那么记录```g(fi)=gcd(a,b)=gcd(g(fi),b)```；再有c也分解出fi，那么记录```g(fi) = gcd(a,b,c) = gcd(g(fi),c)```. 最终g(fi)记录的就是所有fi的倍数的序列的GCD。如果```g(fi)=fi```，那么fi就是一个符合要求的GCD。

假设单次求解一对数字gcd的时间是o(1)。令M表示每个元素的大小上限2e5，数组总元素个是N，那么分解因数的时间是```o(N*sqrt(M))```。每分出一个因数f，就对应一次gcd的计算。
