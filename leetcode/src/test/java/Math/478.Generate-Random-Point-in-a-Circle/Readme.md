### 478.Generate-Random-Point-in-a-Circle.cpp

对于一个圆中的任意一点，如果用```(x,y)```表示的话，我们需要分别生成均匀分布的x和y，但要使得```x^2+y^2<R^2```.所以一种简单粗暴的方法就是随机生成在```[-R,R]```均匀分布的x和y，再考察```x^2+y^2```以reject那些超出范围的采样点。如果```(x,y)```超出范围那就重新再run一遍这个程序，直到所得的```(x,y)```符合要求。很显然，这个方法的缺点就是不够高效，每每跑一次不见得就能得到一个有效的点，运气不好可能会需要跑好几次。

另一种很容易想到的思路，就是尝试用极坐标表示法```(r,theta)```，其中r表示到原点的距离，theta表示射线的角度。在这里定义域就是```r<1```，theta属于```[0,2*Pi)```.直观上，我们可以知道，想要这个点在圆内尽可能随机分布，那么它的角度theta应该是等概率出现的。所以毫无疑问theta应该是一个在```[0,2*Pi)```上均匀分布的。

那么r应该怎么生成呢？r是不是也该在```[0,R)```上均匀分布呢？如果我们自己做一做实验，在一个圆内画几条等角度分布的直径作为“轮辐”，再在直径上等距离的画点，可以发现，我们得到的点的分布在圆内并不是均匀的，很明显这个时候里面的点更密集，外面的点更稀疏。所以这就提示我们，对r做采样的时候不应该在```[0,R)```上均匀分布，而是越靠外越密集些，以补偿刚才这种“内密外疏”的趋势。该怎么调整呢？

一种直观的思路：我们可以这么想，假设当前的半径是r，圆的面积是r^2（忽略常系数），并且认为r^2是一个单位的面积。如果我们将半径扩大一倍变成2r，圆的面积就是4\*r^2，多出了三份单位面积，我们为了保持每份圆环面积的大小r^2不变，我们需要在直径扩大的部分区间```[r,2r]```上取三个采样点。再往外走一步，如果半径变成了3r，那么我们需要在```[2r,3r)```的区间上取9-4=5个点...可见规律是，半径越大的位置，我们沿半径采集的点就需要越密集（以保证每层圆环的面积是均匀一致的），这种取点的累积密集（就是概率分布函数，但注意不是概率密度函数）显然就是r的平方关系。

所以，简单来说，现在有随机变量S的概率分布函数满足S = r^2，如果想要S是沿半径方向```[0,R)```区间呈现均匀分布（也就是一条直线），那么随机变量r（也就是在半径方向上进行取点的抽样）的概率分布函数也必然就是对一个均匀分布的随机变量进行开平方。

Follow Up: 请问如何通过一个在[0,1]上均匀分布的随机变量t，来实现对s的采样，要求采样得到一个新的随机变量s，使得s满足某种概率密度函数分布PDF.（答案就是```CDF^(-1)(t)```，注意CDF是PDF的积分)


[Leetcode Link](https://leetcode.com/problems/generate-random-point-in-a-circle)