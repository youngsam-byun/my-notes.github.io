### 047.Permutations-II

此题是对046.Permutations的follow-up.我们知道，对于46题这种常规的排列，最巧妙的方法就是插入法。对于ｎ个数字组成的全排列，我们只要把第n+1个数字依次插入每个数字间隔之中（包括首尾），那么得到的就是n+1个数字组成的全排列。

但对于此题，这种全排列就会有重复的情况。

比如对于1,1,2三个数字组成的不重复的全排列有这三个：112,121,211.如果此时我们想再加上一个１，该怎么做呢？如果按照之前的方法，第一个会衍生出这四种1112，1112，1112，1121，而第二个会衍生出1121,1121,1211,1211,第三个会衍生出1211,2111,2111,2111。可见不仅每个分支内部的衍生会有重复，不同的分支之间也会有重复。

解决的方法非常巧妙。那就是挨个空插入，但直到遇见相同的元素就停下来。比如，对于112，现在需要插入一个1，那么我们在队首插完之后就停止(因为seq[0]==1),得到的是1112。然后考虑121，同样，也只在队首插入一个１之后停止（因为seq[0]==1），得到的是1121。对于211，我们就可以插入在队首、以及第一个数字之后，然后停止（因为seq[1]==1），得到的分别是1211, 2111。

这个方法能有效避免重复且不遗漏的原因是，112,121,211已经包含了所有n==3的全排列，已有的１已经充分地分布在其中。比如对于112，我们不需要对每个空都插入１，要相信其他序列（121，211)能够覆盖所有情况。

补充：

对于这种改进的“插板法”的理解，可以这么来看。我们将数列中相同的1做区分[1a,1b,2,1c]。按照上述的算法，我们能够保证新插入的1永远是在已经插入的1的前面，即四个数字插完后，里面的三个1永远是1c,1b,1a的顺序，这样就杜绝了因为三个1的乱序而造成的重复的全排列。


[Leetcode Link](https://leetcode.com/problems/permutations-ii)
