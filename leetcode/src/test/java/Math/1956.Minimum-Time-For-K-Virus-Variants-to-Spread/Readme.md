### 1956.Minimum-Time-For-K-Virus-Variants-to-Spread

**引理1：** 给定K个点，存在某个位置M，能够最小化M到所有点的曼哈顿距离的最大值D。结论：这个M一定位于这K个点中距离最远的两个点（记为AB）的连接路径的中点，即```AM + MB = AB = L```，并且```D = (L+1)/2```。

这个结论可以用反证说明：如果M不在所述的位置，那么要么AM会变得比(L+1)/2更大，要么BM会变得比(L+1)/2更大，这样都会使得D更大。有人会问，其他任意点C到M的距离，为什么不可能是曼哈顿距离里的最大值呢？因为对于任意三角形，AB>AC, AB>BC，那么对于AB的中点M，一定有 ```AM = BM > MC```.

**引理2：** 给定K个点{xi,yi}，曼哈顿距离最远的两个点AB之间的距离L，可以计算如下：令 ```a = x + y, b = x - y```. 则 ```L = max(max{|ai-aj|}, max{|bi-bj|})  for all i,j```

本题是希望找到某K个点组成的集合，记其中最大的曼哈顿距离L，如果```D = (L+1)/2 <= K```，那么说明D天后他们的“中心”肯定会被这K个病毒爆发点传染到。我们求所有D中最小的那个。

我们首先将所有的点按照a值排序（前面提到了a=x+y）。我们用两个循环枚举全部的a值区间[i:j]，其中i和j是a值序列的index。对于这个固定的a值区间，前面公式里的“最大a值差”（即```max{|ai-aj|}```），已经是已知的了，就是```aj-ai```。我们此时需思考的是这个区间上的点集的b值范围（前面提到了b=x-y）。我们希望找到K个点，使得他们的最大b值差尽量小。

显然我们只要将这些点再按照b值排个序后，找一段长度为K的滑窗，使得滑窗两端点的b值差最小即可。但是需要注意的是，我们需要保证所选的K个点集的“a值差”仍然是我们之前想要的固定的那个，这意味着我们需要找到i、j这两个点在新建的按照b值排序后的序列里的位置pLeft, pRight。我们用双指针遍历滑动窗口的时候，要求窗口必须包含[pLeft,pRight]这一段。综上，我们在这个b值序列里，遍历所有长度为k、包含[pLeft,pRight]的滑窗，记录最小的“最大b值差”（也就是窗口两端点的b值差）。

总的时间复杂度是 ```o(N^2*NlogN)```

=============================

Update: 以上解法有bug，无法通过新的test case。最大曼哈顿距离是L的点集，并不意味着存在一个中点M，使得M到所有点的距离D不超过(L+1)/2。反例就是[(1,1),(1,2),(2,1),(2,2)].
