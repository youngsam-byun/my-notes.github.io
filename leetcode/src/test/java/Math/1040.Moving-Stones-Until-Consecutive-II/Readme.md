### 1040.Moving-Stones-Until-Consecutive-II

#### 最大数目的移动方案

我们考虑如何最低效率地填充这堆石头内的gap。对于```12____3_4___6```这种类型的分布，我们发现1和2号两个石头可以用来交替填充它们后面的gap。比如说先把1放在2后面（这样消除了一个空格），再把2放在1后面（这样又消除了一个空格），接着又可以把1放在2后面...依次类推，每一次move我们只消除了一个空格，最终直到所有的石头阵内部的gap都被消除（也就是所有的石头都相邻）。我们可以知道，这就是最低效的移动方案了（因为任意一次move都应该至少消除一个gap）。

以上“二人转”策略的关键就是在end point要有两个相邻的石头。那么如果两个端点位置都不满足这个条件怎么办呢？形如```1__2_34__5_6_7```。对于第一步，我们必须移动1或者7，可以考虑两种策略：将1移动到2的后面，或者将7移动到6的前面。显然，将1移动到2之后，在端点处消灭了两个gap；而将7移动到6之前，在端点处消灭了一个gap。所以我们更倾向于第一步移动7，这样效率更低。那么然后呢？然后就有了“二人转”的条件了，就可以实现上一段里描述的策略。

所以总结一下，除了第一步的策略我们需要二选一之外，剩下的移动次数，就是石头阵内部的gap数目。因此最多的移动次数，就是在[1,n-1]区间内的gap个数，以及[0,n-2]区间内的gap个数，取一个较大值即可。即：
```
max {stones[n-1]-stones[1]+1-(n-1), stones[n-1]-stones[1]+1-(n-1)}
```

#### 最小数目的移动方案
一个比较朴素的想法就是，我们要尽量利用已有的、石头分布较密的区间，然后将其他石头往这个区间内搬运。这样一定是效率最高的。于是我们可以在石头阵里遍历一个滑窗[i,j]，滑窗的宽度是n（这个宽度是指的绝对宽度而不是index的宽度）。比如说```abc--d```里面的[a,d]就是宽度为6的滑窗。但是并不是所有宽度为n的滑窗末尾都恰好有石头，比如```abc---e```我们从a开始的宽度为6的滑窗末尾位于石头e之前。所以我们在stones里面搜索滑窗的时候，寻找的其实是一对石头i和j，使得恰好```stontes[j]-stones[i]+1>=n```。

下面分情况讨论：

1. ```stontes[j]-stones[i]+1==n```。 这是说，石头区间[i,j]恰好宽度是n。因为i和j处的石头可以作为端点，其他的石头直接往其区间内部的gap搬运即可。移动的次数其实就是内部的gap的数目。答案就是```n-(j-i+1)```。

2. ```stontes[j]-stones[i]+1>n```。 这是说，石头区间[i,j]宽度大于n。这是因为第stones[i]+n-1处的位置上没有石头。那么我们首先要做的，就是在stones[i]+n-1这个位置（记录为k）先放一块最右边的石头，然后再把其他的石头搬运到[i,k]的区间内。于是操作就需要比上面的多出一步来。（上面的情况，端点处已经有石头了。）

情况2里面有一个非常特殊的corner case，就是形如```OOOO___O```。你无法“在stones[i]+n-1这个位置先放一块石头”，因为你所取的石头是端点，放置的位置也是端点。你能做的就是把左边的石头先拿来做右边界，然后再把左右边的那个石头搬进区间内。这总共需要两步操作。

最终的最小数目的移动方案，需要你遍历所有的滑窗，找到每种滑窗对应的移动次数，再取其中的最小值。






[Leetcode Link](https://leetcode.com/problems/moving-stones-until-consecutive-ii)