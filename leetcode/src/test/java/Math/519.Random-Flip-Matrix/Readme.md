### 519.Random-Flip-Matrix

此题和	710.Random Pick with Blacklist 有些类似。

总共有M\*N个格子。我们每次随机取走一个，count++，那么下一轮可供选择的数目就是M\*N-count个。所以随机数的生成只要在0~M\*N-count-1里面取就行，假设是k，那么问题来了，如果这个随机数k对应的格子我们在之前已经取走了怎么办呢？

为了保证我们每次生成的随机数都可以对应一个依然为0的格子，我们就需要保证，每次取走一个格子，都需要有另外一个合法的格子能够补上这个空缺。举个例子，在第一个回合，我们得到随机数是k，我们把第k个格子返回，但是为了保证以后再抽到k时依然能返回一个0格子，我们就把此时序号最高的0格子，标号是M\*N-1-count，将它指定给第k个位置。于是我们要建立一个Map，建立映射Map[k]=M\*N-1-count，这样下次抽到k时就返回Map[k]即可。

但是，还有问题，如果序号为M\*N-1-count的格子已经在之前被取走过了，怎么办呢？没有关系，虽然序号为M\*N-1-count的格子不在了，但是它所在的位置必然有一个映射Map[M\*N-1-count]标记着一个有效的0格子。这个格子是在之前的某回合中，抽到随机数M\*N-1-count时，如前述所作的相同的映射操作。

因为每个回合都会将count++，所以序号最高的0格子（确切的说是序号最高的key）也会不断下降。所以对于任意抽取的k，要么k是从来没有取走的格子，要么你总能找到Map[k]。




[Leetcode Link](https://leetcode.com/problems/random-flip-matrix)