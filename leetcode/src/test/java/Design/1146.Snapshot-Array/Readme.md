### 1146.Snapshot-Array

最直观的想法就是给每个元素设立快照，即snaps[index]记录了关于index这个元素所有的{snapId, val}。

接下来我们需要考虑一个效率的问题。我们每调用一次snap()是否需要给每个元素都新建一次快照呢？显然如果大多数元素都没有更新过的话，再添加一次快照的效率不高。所以我们可以设置一个changed的集合，里面只存放上一次snap()之后变动过的元素，也就是被set()过的元素。

这样的话，我们会发现对于每个元素而言，它被记录的snapId并不是连续的。比如说snaps[index]={{1,4},{3,8}}，即该元素在第一次拍快照时的值是4，第三次拍快照时的值是8. 那么我们在第二次拍快照的时候，该元素的值是什么呢？显然哪个时候它的值应该是与snapId==1时的值是一样的。所以我们应该在snaps[index]里面找到最后一个小于等于snapId的那个时间戳。

此外还有一个细节，如果某个元素从来没有被更新过，那么snaps[index]里面就是空的，二分搜值就得不到结果。解决方法是，考虑到每个元素的初始值是0，我们给它虚拟地加一个快照{-1,0}，即它的snapId可以认为是-1. 这样get(index,snap_id)的时候至少能得到初始值0.
