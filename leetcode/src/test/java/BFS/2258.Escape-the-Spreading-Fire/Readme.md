### 2258.Escape-the-Spreading-Fire

#### 解法1：2遍BFS
首先，我们容易走两遍BFS，得到两个新矩阵person和fire。其中person[i][j]表示人从起点到达(i,j)点的最短时间，fire[i][j]表示任意火源到达(i,j)点的最短时间。显然我们的关注点就在右下角的位置。我们容易依次做出这些判断：
1. ```person[m-1][n-1] == INT_MAX```，说明人永远到达不了终点，返回-1
2. ```person[m-1][n-1] > fire[m-1][j]```，说明人永远不会比火更早到达终点，返回-1
3. ```fire[m-1][n-1] == INT_MAX```，说明火永远不会达到终点，那么人可以慢慢走，返回1e9
4. 剩下的情况，必然是```person[m-1][j]<=fire[m-1][n-1]```. 我们令```D = fire[m-1][j]-person[m-1][n-1]```表示人比火早到的天数。接下来针对这种情况做详细的分析。

首先，我们保守一点，如果让人停留D-1天再出发，那么人最终达到终点的时间，恰好是火到达终点的前一天，所以还是符合题意的。因此D-1至少是一个解。有人会问，停留D-1天出发，意味着原先人到终点的最短路径要全体抬升D-1，如果保证这条路径上所有的位置依然有```person[i][j]+D-1 < fire[i][j]```呢？事实上，如果停留D-1天，造成人与火同时到达中间某一个位置，那么火就可以借用这条“路径”，必然也会造成人与火同时到达终点。这与之前“人停留D-1天出发，依然会比火早一天到达终点”矛盾。因此这个担忧是不必要的。

接下来是分析的难点。本题虽然不允许中途的任何位置人与火同时到达，但是允许终点位置人与火可以同时到达。所以我们需要考虑再多停留一天，也就是D是否是可行的答案。表面上，人停留D天后，依然可以与火同时到达终点，但是我们发现，如果人与火share同一条路径时，是不合题意的。如下图
```
  F
  O
P O O O D
```
P可以走4步到达终点D，F可以走5步到达终点D。但事实上，P不能停留一天再出发（即5-4）。因为停留的话，人与火会在非终点的位置相遇，这就不合条件。那么该如何判定，人最多是否可以停留D天再出发呢？这个结论比较难总结。答案是：人到终点的最快路径，和火到终点的最快路径，必须是从两个不同方向，即(m-2,n-1)或者(m-1,n-2)进入终点。如下图

```
        F
        O
P O O O D
```
P可以走4步到达终点D，F可以走2步到达终点D。这中情况下，人可以停留两天再出发（即4-2）。因为人与火的最优路径只在终点才相遇。

所以判定D是否能是答案的过程如下顺序：
1. 如果```fire[m-1][n-2]==fire[m-2][n-1]```，说明两个方向上火都是最快路径，人无法避开，所以D不能是答案。
2. 如果```fire[m-1][n-2]<fire[m-2][n-1]```，说明从左边来是火的最快路径，那么我们希望人的最快路径是从上面来，故需查看是否```person[m-2][n-1]==person[m-1][n-1]-1```。是的话返回D。
3. 如果```fire[m-1][n-2]>fire[m-2][n-1]```，说明从上边来是火的最快路径，那么我们希望人的最快路径是从左边来，故需查看是否```person[m-1][n-2]==person[m-1][n-1]-1````。是的话返回D。

判定完以上之后，就返回D-1.

#### 解法2：3遍BFS
在解法1中，我们的难点在于判断D是否是可行的解。其实有一个直观的做法，就是让人在起点停留D天，然后查看一下能否通过BFS顺利到达终点。BFS过程的要求就是人到任何一个中间位置(i,j)的时间，必须小于fire[i][j]，否则就不能加入队列。如果最终能到达终点，就返回D，否则返回D-1.

#### 解法3：二分搜值
既然解法2中写了check函数来判断人停留D天后是否能到终点，那么我们索性就利用这个函数来二分搜值，找到最大的天数使得check的结果是OK。

#### 解法4：BFS+反向Dijkstra
在正向BFS求得fire矩阵之后，假设人到达终点的时间就是fire[m-1][n-1]，然后反向从右下角开始Dijkstra，求得右下角到矩阵每个位置的最短路径。也就是说，我们可以求得一个矩阵，ret[i][j]表示人最晚什么时候到达(i,j)，才能保证能在fire[m-1][n-1]时刻到达右下角。

举个例子，假设右下角的初始时刻是9，相邻的两个位置上有fire[m-1][n-2]是8，fire[m-2][n-1]是10；那么rets[m-1][n-2]就是7，fire[m-1][n-2]是8. Dijkstra的传播过程要遵守两个规则：随着BFS的过程，ret[i][j]必须逐步是变小；其次任何位置上，ret[i][j]必须小于fire[i][j]. 这也解释了为什么得用Dijkstra和PQ，而不是传统的BFS和队列，这是因为相邻两点之间的时间差不一定是1.

最终的答案是ret[0][0].

