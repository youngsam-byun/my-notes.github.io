### 2322.Minimum-Score-After-Removals-on-a-Tree

题目中说要删除两条边，同时考虑的话太复杂吃不消。我们不妨先枚举其中一条边(a-b)，将其砍断的话整张图就变成了两棵树，分别以a和b作为根。此时我们还需要再砍一条边，但这条边只能存在于其中一棵树里面。不妨假设是砍在了a树。那么对于b树，我们就无脑取其所有节点的XOR（记做B）即可。

接下来看a树，需要将其砍一刀变成两个部分。此时我们发现，任意一刀，都会将a树里砍下一棵子树（假设称为c）来。那么我们需要计算的是c子树的节点XOR（记做C），和a子树剩下部分的XOR。突破口来了，剩下部分的XOR，其实就是a子树整体的XOR（记做A），与C做XOR即可。最终这两刀砍成的三个部分，就分别是B，C，和A^C。

此时我们看到，只要在a树里面DFS遍历节点，那么很容易用递归的方法，用o(n)的时间计算每个节点其下方所有孩子的XOR，也就是将其作为c子树的根时所对应的C值。如果我们提前计算了A和B，那么A^C也就马上有了。于是在DFS整棵a树的节点过程中，我们等同于遍历了第二刀的位置，同时立马得到了第二刀砍出的三个部分。

所以本题的思想是，暴力枚举第一刀，然后遍历其中的一颗子树枚举第二刀的位置。总的时间复杂度是o(N^2).

当然，本题还有复杂度优化的空间，比如说用移根的方法来枚举第一刀，简化第二刀的遍历。这里不深究。
