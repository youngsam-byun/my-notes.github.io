### 2003.Smallest-Missing-Genetic-Value-in-Each-Subtree

#### 解法1：贪心
我们考察数值为1的节点记做node。显然对于node的所有子节点，他们的subtree都不会包含1，故1显然就是它们的smallest missing value. 此外，对于node到root的这一条支路而言，其中所有的节点的其他分支，也都不会包含元素1，故它们的smallest missing value也都是1. 于是我们发现，我们要处理的其实就只剩下node到root这一条单链上的节点。

对于这些节点，我们只需要从下往上依次处理即可。每往上走一层，就收集相应分支的节点数值，放在同一个集合里统计smallest missing value。注意到，从下往上的过程中，smallest missing value一定是递增的，所以对所有的节点，我们只要单调递增地去检查答案是什么即可。

#### 解法2：启发式合并集合
更为直观地解题方法是，自下而上维护每个substree所包含元素的集合，然后在这个集合中寻找smallest missing value.这里有两处可以优化的策略。

首先，任一个subtree的根节点node的子元素集合，是来自于所有子节点的元素的合并（再加上node本身的元素）。这里就涉及大量元素的拷贝。事实上，为了减少拷贝量，我们可以将node元素集合“指向”它所有孩子里元素集合最大的那一个（记做s），也就是说，我们只需要以s为基础，加入它的兄弟节点的元素集合，再加上node本身的元素，就直接用来作为node的元素集合。根据这种算法，我们事实上只给所有的叶子节点真正地开辟了集合，而所有非叶子节点的元素集合，都只是借用了它的某一个叶子节点的元素的地址而已。随着层级从下往上，我们会逐渐把所有节点元素都往某一个叶子节点的元素集合里放置。总体的时间复杂度是NlogN.

其次，我们已经有某个subtree的根节点node的子元素集合，那么如何确定它的smallest missing value呢？我们不需要从1开始检查。我们可以从它的孩子节点的smallest missing value里找一个最大值T，从这个值开始逐一递增检查直至找到答案。这是因为元素1到元素T-1一定都会在node的元素集合里。
