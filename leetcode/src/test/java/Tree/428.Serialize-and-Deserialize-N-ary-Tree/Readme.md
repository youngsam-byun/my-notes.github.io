### 428.Serialize-and-Deserialize-N-ary-Tree

此题可以仿照```297.Serialize-and-Deserialize-Binary-Tree```中用先序遍历的思想来编码和解码。

在编码的过程中，我们对于每个节点要存储val之外，还需要存储有多少个child。第二个信息对于重构树的形状很重要，而且它还可以帮助我们在encode时省去存储空的叶子节点。

decode的具体算法：将编码分解为若干个节点（不存在空节点，因为编码的时候省去了）放在数组里。此时cur=0，调用递归函数dfs(cur)。因为数组的第一个元素cur必然就是根节点，我们可以获取```val```和它的孩子的数目```k```。然后我们循环k次，从数组的第cur+1个元素开始依次构建它的k个child节点。更具体地，我们构建了第一个子树dfs(cur+1)之后，数一下这个子树共有k1个元素，那么我们就从数组的第cur+k1+1个元素开始通过dfs(cur+k1+1)构建第二个子树；再数一下这个子树共有k2个元素，就调用dfs(cur+k1+k2+1)构建第三个子树...直至把cur的所有子树都构建完毕。
