### 600.Non-negative-Integers-without-Consecutive-Ones

先考虑一个简单的问题：对于一个n位的01字符串，没有连续1的排列有多少？这是一个简单的DP问题。考虑dp[i]时，如果第i位是0，则1～i-1位可以自由排列为任何无连续1的组合，即dp[i-1]。如果第i位是1，则第i-1位只能是0，那么从1～i-2位可以自由排列为任何无连续1的组合，即dp[i-2].所以动态转移方程是：
```
dp[i]=dp[i-1]+dp[i-2]
```
注意初始条件，dp[0]=1, dp[1]=2; dp[0]是起辅助作用。

那么对于本题而言，我们先将num转化为二进制的字符串。

考虑第i位是1的情况： \***1xxxxxxxxxx，那么如果保留所有的\*且第i位取0，那么第i+1～n位可以自由排列为任何无连续1的组合，都是小于\***1xxxxxxxxxx的，即有dp[n-i]个; 如果第i位取1，那么就要继续查看后面的数组才能保证不大于num。

比如，假设往后看到 \***101xxxxxxxx， 即第i+2位是1（隔了一个0），那么可以重复之前的分析：保留所有\*，将第i+2位取0，则有dp[n-i-2]种排列，它们满足小于\***101xxxxxxxx，且无连续1的条件；如果将第i+2位取1，则需要继续往后查看。

但是，如果看到第i+1位出现了这种情况：\***11xxxxxxxxx，即第i+1位和第i位一样都是1。注意到，第i+1位是不能取1的（否则连续两个1），所以第i+1位只能取0，这样则有dp[n-i-1]种组合符合要求。但特别注意，num在第i+1位之后的数字我们其实就不用查看了，因为第i+1位已经锁定为0了，这样的01组合一定小于等于num。此时就要退出循环。

注意一个细节：如果num从头到尾都没有任何连续的1出现，那么最后就要把result++，因为虽然一路都是把当前位的取值等同于digits[i]，但最后并没有包含num本身。


[Leetcode Link](https://leetcode.com/problems/non-negative-integers-without-consecutive-ones)