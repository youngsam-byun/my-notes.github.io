### 1839.Longest-Substring-Of-All-Vowels-in-Order

#### 解法1：DP
第一类基础型DP。令dp[i][j]表示截止到第i个元素、并且结尾字母是j时的最长美丽串长度。显然，如果word[i]==j，那么前一位的字母必须与j相等或者比j小，即
```cpp
dp[i][j] = max(dp[i-1][j], dp[i-1][j-1])+1;
```
如果word[i]!=j，那么dp[i][j] = INT_MIN;

最终的答案是所有```dp[*][5]```中的最大值。

#### 解法2：贪心
实际上我们可以经验地去判断一个子串的增长是否符合美丽的条件：新增的字母必须比之前的字母相等或者更大，否则就得清零重来。那么时候可以知道收集了五个不同的字母呢？我们可以设计字母的计数器，当新增的字母必须比之前的字母更大的时候，计数器增一；当计数器变成5的时候，就知道我们收集齐了aeiou，此时的len就是一个答案。
