### 2044.Count-Number-of-Maximum-Bitwise-OR-Subsets

因为所有的元素都小于1e5，它们只需要17个bit即可表达。而且不管OR的操作进行多少次，都不会溢出2^17的范围。所以我们可以枚举所有可能的bitwise OR的结果，令dp[val]表示得到val的方案数。类似背包问题，我们每得到一个新的数字x，就可以考虑它的作用，更新一遍所有的dp[val].

注意，本题中的状态转移是从现在转移到未来。也就是已知上一轮的dp[i-1][val]，那么我们此次使用x的话，可以知道这一轮dp[i][val|x]的实现至少能有dp[i-1][val]种方案（就是在原先dp[val]所对应的方案基础上都使用x）。

如果状态转移的策略反过来的话就很难做。因为如果我们想知道本轮的dp[i][val]，就需要穷举上一轮的所有满足```v|x == val```的状态v，这样才能有```dp[i][val] = sum(dp[i-1][v]```. 
