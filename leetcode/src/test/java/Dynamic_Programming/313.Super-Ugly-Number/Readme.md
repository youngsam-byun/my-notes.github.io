### 313.Super-Ugly-Number

#### 解法1
仿效BFS的想法. 从1开始，每次从优先队列里弹出当前最小的数，然后分别乘以k个质数再放入队列中。直至弹出n个数为止。时间复杂度是```NKlog(NK)```.

#### 解法2：
仿效```264	Ugly Number II```，每一个回合，下一个最小的丑数nxt，必然是某个老丑数乘以某个质数。现在有k个质数，说明nxt的候选者其实有k个，分别对应着k个老丑数分别乘以k个质数。所以我们给每个质数prime[j]分配一个指针p[j]指老丑数的位置，这个指针在整个过程中必然是要顺次移动。假设当前nxt的所有候选者中，```prime[j]*rets[p[j]]```最小而胜出，那么就把它加入rets，并且这个质数的指针以后就要右移一位，即```p[j]++```；其他质数的指针不变。

注意到丑数序列的第一个是1，我们重复n-1遍上述的过程，就可以得到答案（第n个丑数）。总的时间复杂度是```o(NK)```.

#### 解法3：
在解法2的基础上，在K个候选新丑数中选择最小的那个时，可以用一个优先队列来实现log(K)的弹出。这样时间复杂度就化简为了```o(NlogK)```.
