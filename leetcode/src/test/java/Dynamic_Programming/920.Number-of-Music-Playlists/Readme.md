### 920.Number-of-Music-Playlists

此题看到结果需要mod 1e9+7,毫无疑问就需要用到DP.怎么定义状态呢?如果没有任何思路的话,不妨就先顺着题目的意思来.题目里说求L个播放器位置播放N首歌的方法,那么就令dp[i][j]表示有i个播放位置,总共用了j首歌的方案总数.注意,这里的"方案"意思是,每相同的两首歌之间至少要有m个间隔.并且"用了j首歌"的意思是,肯定j首歌每首至少用到了一次.

那么dp[i][j]的状态怎么转移呢?一般而言,我们都会考察dp[i-1][j],dp[i][j-1],dp[i-1][j-1]这些旧状态,看看能否通过它们导出新状态.

我们先考虑dp[i-1][j],也就是说在第i-1个位置的时候,已经用了j首歌.那么在考虑dp[i][j]时,第i个位置上,我们依旧只需要从这j首歌里找,只要满足间隔条件就行.那么可供选择的歌的数目就是j-K.当然这里要求j>K才行.

然后我们考虑dp[i-1][j-1],也就是说在第i-1个位置的时候,才用了j-1首歌.那么在考虑dp[i][j]时,在第i个位置上,我们必须用新歌.那么可供选择的歌的数目就是N-(j-1).当然,这里要求N>(j-1).

至于其他的dp[i][j-1],我们无法从这个状态转移到dp[i][j].

所以转移方程为:
```
if (j>K)
  dp[i][j] += dp[i-1][j]*(j-K)
if (N>j-1)
  dp[i][j] += dp[i-1][j-1]*(N-j+1)
```
那么边界条件是什么呢？其实非常简单，就是dp[1][1]=N. 只有一个播放位置,并且只能放一首歌,自然有N种选择.

回过头来看一看上面的方程,发现确实很巧妙,任何不符合逻辑的dp[i][j]都不会被赋值。


[Leetcode Link](https://leetcode.com/problems/number-of-music-playlists)