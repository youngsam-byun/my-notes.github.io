### 818.Race-Car

试想一下，到达target的路径可能会有哪几种模式。需要特别注意的是，最后达到终点的时候可能是正向的，也可能是反向的。所以需要分成这么两大类：

1. 到达target时是正向的。这包括：
a. 最幸运的是，直接加速一路恰好到达。（这种情况可以提前处理）
b. 先正向加速一段，然后停止（为了减速到零），然后继续到达终点。
c. 先正向加速一段，然后反向走一段，然后再正向，最后继续到达终点。
其中b和c两种情况其实可以归并为一类，只是反向走的路程的长短不一样而已。

2. 到达target时是反向的。于是这需要先正向加速一段冲过target，然后反向，继续到达终点。

在第一大类和第二大类的情况中，正向加速分别到什么时候为止呢？直觉告诉我们：加速到恰好不超过target的时候，即为分界线。也就是当```n=log2(target+1)```时，```2^(n)-1```表示正向加速不超过target的最远距离；相应的```2^(n+1)-1```就是恰好超过target的最近距离。

第一大类中，确定了n，那么可以遍历反向的步数k，再用递归求解总的步数。也就是说：前向走n步，反向，反向走ｋ步，再反向，剩下的递归．
```cpp
for k = 0,1,2,...,n-1
  dp[target] = min(n+1+k+1+racecar(target-(2^n-1) + (2^k-1)))
```
第二大类中，确定了n，可以直接用递归求解剩余的步数
```cpp
dp[target] = n+1+1+(2^(n+1)-1-target)
```
最后dp[target]取上述几种讨论的最小值．


[Leetcode Link](https://leetcode.com/problems/race-car)