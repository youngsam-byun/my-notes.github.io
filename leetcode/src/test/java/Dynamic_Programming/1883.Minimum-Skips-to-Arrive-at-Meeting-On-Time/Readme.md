### 1883.Minimum-Skips-to-Arrive-at-Meeting-On-Time

虽然本题和```1870.Minimum-Speed-to-Arrive-on-Time```很像，但是本题的本质是DP。

我们令dp[i][k]表示走完第i条路、且skip了k次休息的条件下，所需要的最短时间（这是一个浮点数）。注意，这里走完了第i条路，要包括了走完该路程后的休息时间（如果选择在该路结束后休息的话）。当然，走完最后一条路的话是不需要休息的。

对于第i条路，如果我们不skip rest，那么在开始走第i条路之前所用的时间就是dp[i-1][k]（包括第i-1条路结束后可能的休息），然后紧接着第i条路需要```dist[i]*1.0/speed```，然后休息的结果是二者的时间之和向上取整，即```ceil (dp[i-1][k] + dist[i]*1.0/speed) ```.

对于第i条路，如果我们skip rest，那么在开始走第i条路之前所用的时间就是dp[i-1][k-1]（包括第i-1条路结束后可能的休息），然后紧接着第i条路需要```dist[i]*1.0/speed```，不休息意味着不需要向上取整。总时间就是二者之和```dp[i-1][k] + dist[i]*1.0/speed ```.

综上，dp[i][k]就是选二者较小的那个。

特别注意，走完最后一条路（第n条）之后不需要休息，不占用skip rest的计数，所以```dp[n][k] = dp[n-1][k] + dist[n]*1.0/speed ```

最终的答案是最小的j，使得```dp[n][j]<=beforeHours```

特别注意，因为精度问题，取ceil之前的浮点数要减去一个极小数eps。
