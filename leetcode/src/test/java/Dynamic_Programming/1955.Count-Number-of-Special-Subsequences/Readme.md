### 1955.Count-Number-of-Special-Subsequences

这道题只有三种字符，容易给人一种可以用双指针来遍历边界的错觉。但是双指针需要N^2的时间复杂度，不适合此题。

事实上这题如果想到用DP，算法并不难写。我们令dp[0]表示截止到元素i的位置、以0结尾的子序列的个数。注意，为了保证合法，这样的序列必须只包含0. 同理我们令dp[1]表示截止到元素i的位置、以1结尾的子序列的个数，这样的子序列必须只有0与1，且0都在1之前。令dp[2]表示截止到元素i的位置、以2结尾的子序列的个数，这样的子序列必须只有012，且依次出现。

我们发现，当nums[i]=0的时候，对于dp[1]和dp[2]没有影响，因为我们无法使用这个0得任何新的01序列或者012序列。但是对于已有的纯0序列，我们可以有两种操作：附加上这个位置上的0以构造出新的序列，或者不附加维持原来的纯0序列。这样dp[0]的种类其实就相当于翻倍了，故经过这个位置后，```dp[0] = dp[0]*2```

同理，当nums[i]=1的时候，对于dp[0]和dp[2]没有影响。那么01序列的个数如何变化呢？同样两种操作：不附加这个1，那么原来有多少01序列，现在仍然有多少01序列。附加这个1，那么原来有多少纯0序列和01序列，都会因为添加了这个1成为了一个新的01序列。所以经过这个位置后的01序列包括了三部分：```dp[1] = dp[1] + dp[0] + dp[1]```

同理，当nums[i]=2的时候，对于dp[0]和dp[1]没有影响。那么012序列的个数如何变化呢？同样两种操作：不附加这个2，那么原来有多少012序列，现在仍然有多少012序列。附加这个2，那么原来有多少01序列和012序列，都会因为添加了这个2成为了一个新的012序列。所以经过这个位置后的012序列包括了三部分：```dp[2] = dp[2] + dp[1] + dp[2]```

最终的答案就是在最后一个位置后的dp[2]。

本题的难点是初始状态的设计。我们可以想象，如果我们把三个量都初始化为0的话，那么所有的结果都依然为0. 所有我们不得不给一个初始的“动量”，就是令dp[0]=1. 但是这样会出现一个问题，dp[0]所表示的纯0序列的个数，其实包括了零个0的情况。当我们构造01序列时候，要求纯0序列的部分不能为空，所以对于dp[1]需要改动为```dp[1] = dp[1] + (dp[0]-1) + dp[1]```. 注意，对于dp[1]和dp[2]的表达式，我们都保证了1和2的个数都不为零，故我们没有类似的担心。经过修改后，dp[1]和dp[2]都能准确地表示合法的01序列和012序列的个数。
