### 1449.Form-Largest-Integer-With-Digits-That-Add-up-to-Target

这是一道有点类似完全背包的DP问题。

令dp[cap]表示使用总分为cap所能得到的最优解（即最大的数字的字符串形式）。突破口是考察最后一个数字i是什么。我们遍历i的可能性：只要cap>=cost[i]，那么dp[cap]就可以由dp[cap-cost[i]]追加数字i转化而来。我们在所有的i中，找一个能使dp[cap]最大的解。注意，这里的“最大解”，在字符串意义而言，首先是越长越好，其次是相同长度下字典序越大越好。

注意体会这和01背包问题解法的不同。01背包问题的外循环是遍历物品，内循坏是遍历容量。每考虑一件物品，更新所有的dp[cap]。

相反，完全背包问题的外循环是遍历容量，内循环是遍历（最后一次使用的）物品。每考虑一个容量cap，搜索最优的dp[cap].
