### 1909.Remove-One-Element-to-Make-the-Array-Strictly-Increasing

本题的难点是如何不用暴力的线性时间的算法。

#### 解法1 (有瑕疵)：

根据To do or not to do的套路，对于这种“行使权力”的题目，我们很容易想到设计两个状态分别对应“没有删除元素”和“删除了一个元素”。在这里我们令dp0[i]表示：我们从未删除过元素、截止到i的最长连续递增序列的长度。同理令dp1[i]表示：我们已经删除过一个元素、截止到i的最长连续递增序列的长度。特别注意我们的定义，所谓“截止到i”，意思是这个最长递增序列必须以i结尾（即包含nums[i]）。也就是说，如果我们打算删除第i个元素，那么dp1[i]就应该是0.

先考虑dp0[i]，它有两个来源。首先，如果nums[i]>nums[i-1]，显然这个递增序列可以在前一个未使用删除权力的递增序列的基础上延长，即```dp0[i] = dp0[i-1]+1```. 其次，如果nums[i]<=nums[i-1]，那么以“截止到i的最长递增序列”只能是它自身，也就是```dp0[i] = 1```.

在考虑dp1[i]，它也有两个来源。首先，就是我们已经使用过了删除权力，那么我们可以在前一个已经使用删除权力的递增序列的基础上延长，即```dp1[i] = dp1[i-1]+1```，当然前提是nums[i]>nums[i-1]. 另外一个来源就是在这个回合使用删除权力。记住，我们不能删除nums[i]本身，因为dp1[i]的定义要求包含nums[i]，我们只能删除nums[i-1]（否则就会等同于前述的情况），这样dp1[i]是接在上一个未使用删除权力的递增序列的基础上延长，即```dp1[i] = dp0[i-2]+1```. 最后dp1[i]在这两个source中选较大的那个。

最终的答案是查看所有i的位置，如果有```dp0[i]>=n```或者```dp1[i]>=n-1```就说明实现目标。

#### 解法2：
令maxNon表示截止到目前为止、未使用过删除权力、最长第增序列的最大值；令maxUsed表示截止到目前为止、已经使用过删除权力后、最长第增序列的最大值。这里不要求当前元素一定是这个递增序列的一部分。

如果当前元素大于maxNon，那么maxNon就可以更新。反之，那么就无法延续当前的递增序列，我们令maxNon为无穷大。

如果当前元素大于maxUsed，那么maxUsed就可以在原先的maxUsed基础上更新。另外，我们也可以删除当前的元素，那么maxUsed就继承maxNon。这两个方案我们取较小的那个，目的是为了便于后续第增序列的延长。

最终maxNon或者maxUsed任意一个为非无穷大的话，说明有解。

#### 解法3：
我们一旦发现某两个相邻的元素不满足严格递增，即```nums[i]>=nums[i-1]```，那么说明这两个元素之中一定存在“破坏递增”的那个bad number。我们再pass两遍，分别跳过这两个元素，看看剩下的序列是否为严格递增。如果都无法保证严格递增，那么说明只删除一个bad number是无法实现要求的。

#### 解法4：
利用nlogn解法，求原数组里的longest increasing subsequence，看看长度是否大于等于 nums.size()-1.
