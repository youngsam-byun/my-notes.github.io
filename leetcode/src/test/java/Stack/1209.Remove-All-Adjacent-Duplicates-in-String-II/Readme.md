### 1209.Remove-All-Adjacent-Duplicates-in-String-II

模拟整个消除的过程是比较笨拙的方法。优秀的方法可以用one pass来得到最终的结果。

考虑```aabbbadd```，k=3这个例子。第一轮消除```bbb```之后会遇到一个```a```，如果是纯模拟的话，第一轮并不会处理这个字符，但是考虑到```bbb```之前已经有两个```a```了，现在等于有三个连续的相同字符放在一起了，肯定能在第二轮被消除掉，何不就在one pass的时候一并做了呢？

显然，我们可以用栈的数据结构来实现这个功能。一个需要考虑的问题是，我们如何快速判定栈顶有几个```a```以便我们决策是否要退栈做k消除？方法是我们在入栈的时候不仅放入字符，而且放入一个数字来统计目前栈顶有多少个连续的相同字符。这样我们只需看一下最栈顶的元素，就知道栈顶有多少个连续的相同字符了。
