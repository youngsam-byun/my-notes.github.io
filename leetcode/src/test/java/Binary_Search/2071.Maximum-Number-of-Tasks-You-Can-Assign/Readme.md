### 2071.Maximum-Number-of-Tasks-You-Can-Assign

这道题如果正面硬刚的话比较棘手。对于任何一个task，我们首先不清楚它是否一定要被选中。即使要选中，它是应该分给一个能够单干的工人，还是分给一个吃了大力丸的工人？同样，对于任何一个工人，我们也不清楚他是否一定要被选中，或者他是选择单干一个task，还是吃一个大力丸再找一个task。

因为本题的解其实是有明确的范围的，即从0件到所有的task。所以我们可以考虑二分搜值，即猜测我们能够完成k件，看一下是否能够有一个合法的方法。

我们发现如果给定了完成k件的指标，就多了很多信息。首先这k件任务一定是难度最低的k件。我们先考虑其中难度最大的。这个难度最大的任务应该是必须完成的，所以它首先会找能力最强的worker，这是因为最强能力的工人如果不去做最难的任务，那么做其他简单任务就是浪费能力。于是就会有两种情况：
1. 当前最强工人能够单干解决它，那么就把这个任务和工人配对，记得将已经配对的工人剔除。
2. 如果当前最强工人不能单干解决它，那么意味着我们必须要找一个工人吃大力丸来解决。显然，我们不一定要找最强工人去吃大力丸，我们只需要找一个刚刚好的工人，使得```worker+strength >= task```即可。于是这就提示我们需要将所有的worker排好序，用lower_bound来找到这个刚刚好的工人。完成这次配对之后，这个工人必须剔除。考虑到以后处理其他task时我们可能还需要剩余的工人保持有序状态，所以我们必须使用类似multiset的数据结构来保证删除一个元素之后仍然自动有序。

通过以上方法，就可以贪心地确认每个task应该分给哪个工人。如果指定的k任务都能顺利分配，那么二分搜值的checkOK就可以返回true，可以考虑在下一个回合提升k；反之就要减少k。
