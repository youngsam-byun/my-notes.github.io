### 564.Find-the-Closest-Palindrome

这是一道比较难的题目。

看到题目最直观的想法是，将数字的前半部分翻转后拼接到后半部分，比如说12345，那么我们就找12321.

但是这样的策略不是万能的，因为找到不一定是离原数最接近的。比如12399，如果我们选择直接翻转，12321就不是最优解，最优解应该是12421. 再比如19200,直接翻转的19291不是最优解，最优解是19191. 那么我们就可以见端倪了，对于形如ABCXX的形式，我们应该在ABCBA，AB(C+1)BA，AB(C-1)BA之间选择一个最接近原数的就可以了。同理，对于ABXX的形式，我们采用类似的加一减一再复制翻转的方式，于是就应该在ABBA，A(B+1)(B+1)A，A(B-1)(B-1)A之间选择一个最接近原数的。

但这样的话，又会有个问题，例如12088，中间的0如果减去１的话就变成9了，翻转复制就成了12921和，这与原数相差也太大了．所以我们改进上面的方法，不再只对中间的数字加减，而是对前三位120整体做加减，然后复制翻转拼接（合并掉中间一位以保证仍然是奇数位），得到11911,12021,12121．那么我们对于偶数位也采取相同的方法，例如2088,我们对20整体进行加减操作，然后复制翻转拼接（不用合并掉中间一位，因为期望仍然是偶数位），得到1991,2002,2112.

但是，如果遇到加减之后位数变化的情况怎么办呢？比如10001,我们对前三位100减１之后得到的99，复制翻转拼接之后得到的999，位数一下子就少了两位．类似的对于999，我们如果对于前两位99加一变成100,复制翻转拼接后变成10001,位数一下子就多了两位．类似的情况对于偶数位的数字也会出现．怎么办呢？方案是，我们照做不误，反正最后筛查所有候选答案的时候，这些偏差太大的候选人一定会被去掉的．但是，我们需要同时考虑到这种位数变化的情况，所以干脆也加入到候选者来．比如给出的某个n位数，那么我们就把n+1位数的100...0001直接放入候选，n-1位数的99...99也直接放入候选．

综上，我们有了得到五个候选人的方案,最后筛查一下．去除不是回文数的（注意有可能候选人不是回文数），选取和原数最接近的就是答案了．


[Leetcode Link](https://leetcode.com/problems/find-the-closest-palindrome)