### 048.Rotate-Image

#### 解法1 
将整个方阵分为四个象限。可以想象，将整个方阵顺时针旋转90度，就等于将各个象限关于坐标原点旋转９０度。特别需要注意到，四个象限分别有一个点，这四个点在旋转过程中是彼此重合的。我们以4\*4的方阵为例：对于左下角的坐标A(0,0)，对应的左上角的位置是B(3,0)，右上角的位置是C(0,3)，右下角的位置是D(3,0).我们如果将方阵旋转一周，这四个点的元素会分别变成B，C，D，A。

所以我们只要遍历一个象限中的所有点，让每个点调整它在四个象限中对应的位置即可。比如说在第一象限中的（x，y），旋转后在下一个象限中的位置就是(N-1-y,x)。我们将象限Ｉ与II交换，再把II与III交换，再把III与IV交换，注意通过三次交换，而不是四次，即可将这四个点形成旋转90的效果。举个例子：ABCD->BACD->BCAD->BCDA.

对于N为奇数的情况，除了四个象限外，还多出四个对称的坐标轴不属于任何象限。我们可以将四个坐标轴分别归给每个象限，这样就不用再单独对它们做处理了。所以外层循环的框架对于i和j遍历范围是略微不同的：
```cpp
for (int i=0; i<N/2; i++)
  for (int j=0; j<(N+1)/2; j++)
     ...
```     

#### 解法2 
我们先考虑一个横向长条型的“向量”A，它旋转90度之后，变成了纵向长条形的向量，恰好就是它的转置A'。转置操作很容易用in-place实现，```swap(matrix[i][j],matrix[j][i])```即可。

接下来考虑两行横向长条型的向量[A;B]，如果依然是转置操作的话，变成了[A',B']. 但是我们希望旋转90度的样子其实是[B',A']。可见我们只需要将转置后的方阵再做左右对称交换，就是想要的90度旋转。

特别注意，无论是转置还是左右交换，我们只需要对一半的元素进行操作即可。如果对全部的元素进行swap，等于又变回去了。


[Leetcode Link](https://leetcode.com/problems/rotate-image)
