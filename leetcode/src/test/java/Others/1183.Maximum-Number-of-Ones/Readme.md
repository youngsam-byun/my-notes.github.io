### 1183.Maximum-Number-of-Ones

考虑到width的大小，在横方向只能放下```n1=width/sideLength```个完整的正方形，且剩下来有```d1=widht%sideLength```这个宽度的“边角料”。因为这n1
个完整的正方形，每个都确定能放下maxOnes个1，所以唯一能做文章的就是靠最右边的“边角料”区域而已。

有人会说，除了这n1个完整的正方形（以第0列为起点），还有很多有其他初始offset的正方形（比如说以第1列为起点，边长仍为sideLength）没有被考虑。但事实上，如果偏移为0的这n1个正方形，其1元素分布图案都是一致的，那么我们可以想象，对于任何正方形（不管起始的偏移量是多少），其内部1元素的数量都依然还是maxOnes（只不过有了shift）。所以这些完整的正方形（不管偏移量多少）都不用担心。我们只关心初始offest为0的正方形排列满之后剩下的那快边角料。

同理，在column方向，我们也以sideLength不停往下垒正方形。最终在下方也剩有一块边角料。

所以我们的问题就转换为：设计一种sideLength为边长的正方形的图案，使得里面的1元素的个数是maxOnes；并且将这个pattern移动到右边和下方的“边角料”区域时，这些“边角料”区域内能被1覆盖的面积越大越好。

解决方案其实很简单：将所有的边角料区域映射都到一个```side*side```的正方形区域内。然后在这个正方形区域内找出被映射次数最多的前maxOnes个格子。对于每一个正方形，我们都将这些格子都标记为1，就能得到了最优的图案。


[Leetcode Link](https://leetcode.com/problems/maximum-number-of-ones)