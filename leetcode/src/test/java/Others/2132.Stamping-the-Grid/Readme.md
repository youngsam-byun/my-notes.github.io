### 2132.Stamping-the-Grid

#### 解法1：二维区间和
遍历grid的每一个位置(i,j)，考察以(i,j)为左上角、(x,y)为右下角、形状等同于邮票的区间，如何快算判断这个区域是否可以合法放置邮票呢？显然用一个预处理的二维区间和查询即可。这样我们就可以求出所有可以合法放置邮票的区域，将右下角的位置都标记为1，存储在二维数组stamps里面。

然后我们再遍历grid里面的每一个非1的点位(i,j)，考察它是否可能被某一个stamp覆盖。怎么做到呢？只要考察以(i,j)为左上角、(x,y)为右下角、形状等同于邮票的区间，看看stamps数组在这个区间里的元素和是否大于0. 是的话那么必然有一个合法的stamp能够覆盖(i,j)，否则的话就可以返回false。

#### 解法2：二维差分数组
我们来复习一下二维差分的模板。假设二维矩阵为f[i][j]。我们构造与之对应的差分数组diff[i][j]. 如果我们想将以(x0,y0)为左上角、(x1,y1)为右下角的矩形区域统一加上val，那么我们只需要在diff数组上做标记：
```
diff[x0][y0]+=1;
diff[x0][y1+1]-=1;
diff[x1+1][y0]-=1;
diff[x1+1][y1+1]+=1;
```
这样的操作可以进行多次。如果我们想重构更新后的f的值，需要做如下操作：
```
for (int i=0; i<m; i++)
    for (int j=0; j<n; j++)
    {               
        f[i][j] = f[i-1][j] + f[i][j-1] - f[i-1][j-1] + diff[i][j];
    }
```
此时可以输出任意f里的任意数值。注意，由上面的公式可以看出，diff数组的维度要比f大一点。计算f时，如果遇到越界的格子，默认为0.

模板代码见[这里](https://github.com/wisdompeak/LeetCode/blob/master/Template/Diff_Array_2D/code.cpp)

在本题里，如果grid[i][j]的一个格子是叉，那么以其为左上角、形状同shape的区域内，任意一个点都不可能作为合法放置邮票的右下角（否则一定会覆盖到grid[i][j]）。所以我们处理完所有的叉点之后，就可以把所有不能合法放置邮票的（右下角）位置都标记到了（即二维差分数组重构后数值大于零的位置）。

下一步，就是遍历所有残存的、可以合法放置邮票的位置，标记以其为右下角、形状同shape的区域。如果整个矩阵内存在未被标记到、并且不是叉点，那就返回false。
